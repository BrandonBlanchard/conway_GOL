{"version":3,"sources":["components/tile.jsx","classes/a-star.js","components/grid.jsx","App.js","serviceWorker.js","index.js"],"names":["Tile","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","type","weight","isPath","Math","floor","react_default","a","createElement","className","getTypeClass","getWeightClass","getPathClass","React","Component","AStar","updateWeightsCB","field","potentials","startLocation","x","y","tile","endLocation","foundEnd","path","Reset","findStartEnd","floodNode","length","width","height","push","current","shift","nx","ny","nodeIsPotential","processHeuristicWeight","setTimeout","floodFromNextNode","currentWeight","inRange","traceBack","bind","end","traceNext","getLowestTravelCostNeighbor","_this2","dirs","lowest","i","direction","console","log","Grid","routeFinder","updateWeights","assertThisInitialized","init","generateGrid","newState","h","w","tileType","getRandomType","placeStartEnd","UpdateField","setState","random","clearSpaceAroundPoint","abs","map","dir","updatedField","style","row","rowIndex","tileIndex","tile_Tile","key","onClick","FindRoute","App","grid_Grid","Boolean","window","location","hostname","match","ReactDOM","render","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c807eb94.chunk.js","sourcesContent":["import React from 'react';\n\nexport default class Tile extends React.Component {\n    constructor (props) {\n        super(props);\n\n        this.state = {\n            type: props.type,\n            weight: props.weight || 0, // 255 on the high end\n            isPath: props.isPath || false\n        }\n    }\n\n    getTypeClass () {\n        switch (this.state.type) {\n            case 'wall':\n                return 'tile--wall';\n            case 'start':\n                return 'tile--start';\n            case 'end':\n                return 'tile--end';\n            default:\n                return 'tile--open';\n        } \n    }\n\n    getWeightClass () {\n        if(this.state.weight < 1) {\n            return 'weight--0';\n        }\n        \n        let val = Math.floor((this.state.weight / 355) * 100);\n        \n        return 'weight--' + val;\n    }\n\n    getPathClass() {\n        if(this.state.isPath) {\n            return ' path';\n        }\n\n        return '';\n    }\n\n    render () {\n        return (\n            <div className={ this.getTypeClass() + \" \" + this.getWeightClass() + this.getPathClass() }></div>\n        );\n    }\n}","import { debug } from \"util\";\n\n\n\nexport default class AStar {\n\n    constructor (updateWeightsCB) {\n        this.field = [];\n        // The potentials queue, this holds all potential nodes.\n        this.potentials = [];\n        this.updateWeightsCB = updateWeightsCB;\n        this.startLocation = {\n            x: null,\n            y: null,\n            tile: null\n        };\n\n        this.endLocation = {\n            x: null,\n            y: null,\n            tile: null\n        };\n        this.foundEnd = false;\n        this.path = [];\n    }\n\n    Reset() {\n        this.potentials = [];\n        this.startLocation = {\n            x: null,\n            y: null,\n            tile: null\n        };\n\n        this.endLocation = {\n            x: null,\n            y: null,\n            tile: null\n        };\n        this.foundEnd = false;\n        this.path = [];\n    }\n\n    UpdateField (field) {\n        this.field = field;\n        this.Reset();\n    }\n\n    FindRoute () {\n        this.potentials = [];\n        this.findStartEnd();\n        this.floodNode(this.startLocation.x, this.startLocation.y);\n    }\n\n    inRange(x,y) {\n        if(x >= 0 && y >= 0 && x < this.field[0].length && y < this.field.length) {\n            return true;\n        }\n\n        return false;\n    }\n\n    findStartEnd () {\n        const width = this.field[0].length;\n        const height = this.field.length;\n        \n        for(let x = 0; x < width; x += 1) {\n            for(let y = 0; y < height; y += 1) {\n                if(this.field[x][y].type === \"start\"){\n                    this.startLocation.x = x;\n                    this.startLocation.y = y;\n                    this.startLocation.tile = this.field[x][y];\n                    this.potentials.push({x: x, y: y, tile: this.field[x][y]});\n                }\n\n                if(this.field[x][y].type === \"end\"){\n                    this.endLocation.x = x;\n                    this.endLocation.y = y;\n                    this.endLocation.tile = this.field[x][y];\n                }\n            }\n        }    \n    }\n\n    floodFromNextNode() {\n        // If we've found the end, stop searching and trace the path back.\n        if(this.foundEnd) { return; }\n\n        // If the field has been reset or a new path request has been made don't continue with the last route search\n        if(this.potentials.length < 1) { return; }\n\n        const current = this.potentials.shift();\n     \n        this.floodNode(current.x, current.y);\n        this.updateWeightsCB(this.field);\n    }\n\n    // This takes in the location of a potential node that has already been weighted\n    // then looks at its neighbors and gives them a weight/adds them to the potentials queue\n    floodNode (x,y) {\n        const current = this.field[x][y];\n\n        //this.processHeuristicWeight(x,y, current.weight);\n\n        // Top\n        let nx = x;\n        let ny = y - 1;\n        if(this.nodeIsPotential(nx, ny)) {\n            this.processHeuristicWeight(nx,ny, current.weight);\n            this.potentials.push({x: nx, y: ny, tile: current});\n        }\n\n        // Right\n        nx = x + 1;\n        ny = y;\n        if(this.nodeIsPotential(nx, ny)) {\n            this.processHeuristicWeight(nx,ny, current.weight);\n            this.potentials.push({x: nx, y: ny, tile: current});\n        }\n\n        // Bottom\n        nx = x;\n        ny = y + 1;\n        if(this.nodeIsPotential(nx, ny)) {\n            this.processHeuristicWeight(nx,ny, current.weight);\n            this.potentials.push({x: nx, y: ny, tile: current});\n        }\n\n        // Left\n        nx = x - 1;\n        ny = y;\n        if(this.nodeIsPotential(nx, ny)) {\n            this.processHeuristicWeight(nx,ny, current.weight);\n            this.potentials.push({x: nx, y: ny, tile: current});\n        }\n\n        setTimeout(() => { this.floodFromNextNode()}, 0);\n    }\n\n    // For now just assume that traveling one space is a cost of 3\n    processHeuristicWeight(x,y, currentWeight) {\n        this.field[x][y].weight = currentWeight + 5;\n    }\n\n    nodeIsPotential(x,y) {\n        // If this node is out of range, it's not a potential\n        if(!this.inRange(x,y) || this.foundEnd) { return false; }\n\n        const current = this.field[x][y];\n\n        if(current.type === 'start') {\n            return false;\n        }\n\n        if(current.type === 'end') {\n            this.foundEnd = true;\n            this.potentials = [];\n            \n            setTimeout(this.traceBack.bind(this), 0)\n            \n            return false;\n        }\n\n        // If this node is a wall, it is not a potential\n        if(current.type === 'wall') {\n            return false;\n        }\n\n        // If we've already evaluated this space.. ignore it.\n        if(current.weight > 0) {\n            return false;\n        }\n\n\n        return true;\n    }\n\n    traceBack() {\n        // Start from the end node and follow the lowest cost nodes back to the start.\n        const end = this.endLocation;\n        this.traceNext(end.x, end.y);\n\n    }\n\n    // Look at neighbors, find the lowest cost, designate the lowest cost as the path.\n    traceNext (x,y) {\n        this.getLowestTravelCostNeighbor(x,y);\n    }\n\n    getLowestTravelCostNeighbor (x,y) {\n        let dirs = [\n            // North, East, South, West\n            [x, y-1], [x+1, y], [x, y+1], [x-1, y] \n        ];\n\n        // Default value that any tile should be able to beat.\n        let lowest = { tile: { weight: 2000 } };\n        \n        // Find the lowest neighbor\n        for(let i = 0; i < 4; i += 1) {\n            const direction = { x: dirs[i][0], y: dirs[i][1]};\n\n            if(this.inRange(direction.x, direction.y)) {\n                const tile = this.field[direction.x][direction.y];\n                \n                if(tile.type === 'start') {\n                    return;\n                }\n\n                if(tile.type === 'end' || tile.type === 'wall' || tile.weight === 0) {\n                    continue;\n                }\n\n                if(tile.weight < lowest.tile.weight ) {\n                    lowest = {x: direction.x, y: direction.y, tile: this.field[direction.x][direction.y]};\n                }\n            }\n        }\n\n        // Designate the lowest as a path and update the map.\n        console.log('I picked', lowest.tile.weight, lowest.tile.type);\n \n        lowest.tile.isPath = true;\n        this.updateWeightsCB(this.field);\n\n        setTimeout( () => { this.traceNext(lowest.x, lowest.y) }, 0);\n    }\n}","import React from 'react';\nimport Tile from './tile';\nimport AStar from './../classes/a-star';\n\nexport default class Grid extends React.Component {\n    constructor (props) {\n        super(props);\n\n        this.routeFinder = new AStar(this.updateWeights.bind(this));\n        this.init = false;\n        this.state = {\n            width: props.width || 32,\n            height: props.height || 32,\n            field: []\n        }\n    }\n    \n    componentDidMount () {\n        if(!this.init) {\n            this.generateGrid();\n            this.init = true;\n        }\n    }\n\n    generateGrid() {\n        const newState = this.state;\n        let field = [];\n\n        // Generate the grid\n        for(let h = 0; h < this.state.height; h += 1) {\n            field.push([]);\n\n            for(let w = 0; w < this.state.width; w += 1) {\n                let weight = 0;\n                let tileType = this.getRandomType(h,w);\n                \n                if(tileType === 'wall') {\n                    weight = 0;\n                } \n\n                field[h].push({ weight: weight, type: tileType, isPath: false });\n            }\n        }\n\n        this.placeStartEnd(field);\n\n        this.routeFinder.UpdateField(field);\n\n        newState.field = field;\n        this.setState(newState);\n    }\n\n    placeStartEnd (field) {\n        let x = Math.floor(Math.random() * this.state.width);\n        let y = Math.floor(Math.random() * this.state.height);\n        \n        field[x][y] = { type: 'start', weight: 0};\n        this.clearSpaceAroundPoint(field, x ,y);\n\n        x = Math.abs(x-31);\n        y = Math.abs(y-31);\n\n        field[x][y] = { type: 'end', weight: 0};\n        this.clearSpaceAroundPoint(field, x ,y);\n    }\n\n    clearSpaceAroundPoint(field, x ,y) {\n        const dirs = [ \n                [x-1, y-1], [x, y-1], [x +1, y-1],\n                [x-1, y],  /*Current*/ [x+1, y],\n                [x-1, y+1], [x, y+1], [x+1, y+1]\n            ]\n\n        dirs.map(dir => {\n            if(this.inRange(dir[0], dir[1])){\n                field[dir[0]][dir[1]] = { type: 'open', weight: 0 }\n            }\n        });\n    }\n\n    inRange(x,y) {\n        if(x > 0 && y > 0 && x < this.state.width && y < this.state.height) {\n            return true;\n        }\n\n        return false;\n    }\n\n    getRandomType() {\n        let ran = Math.random() * 20 + 1;\n        \n        if(ran > 15) {\n            return 'wall';\n        }\n\n        return 'open';\n    }\n\n    getRandomWeight () {\n        return (1 + (Math.random() * 255));\n    }\n\n    updateWeights (updatedField) {\n        const newState = this.state;\n        newState.field = updatedField;\n\n        this.setState(newState);\n    }\n\n    render () {\n        return (\n            <div className=\"grid\" style={ {width: \"\" + 10 * this.state.width + \"px\"} }>\n                \n                { this.state.field.map( (row, rowIndex) => {\n                    return(\n                        row.map( (tile, tileIndex) => {\n                            return (<Tile key={rowIndex + tileIndex + tile.type + tile.weight + tile.isPath} type={ tile.type } weight={ tile.weight} isPath={ tile.isPath }></Tile>)\n                        })\n                    );\n                })}\n                \n                <div className=\"controls\">\n                    <button onClick={this.generateGrid.bind(this)}> Regen </button>\n                    <button onClick={this.routeFinder.FindRoute.bind(this.routeFinder)}> Start </button>\n                </div>\n            </div>\n        );\n    }\n}","import React, { Component } from 'react';\nimport Grid from './components/grid';\nimport './App.scss';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"app\">\n        <Grid></Grid>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}